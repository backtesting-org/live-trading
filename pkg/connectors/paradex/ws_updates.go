package paradex

import (
	"github.com/backtesting-org/kronos-sdk/pkg/types/connector"
	"github.com/backtesting-org/kronos-sdk/pkg/types/kronos/numerical"
)

func (p *paradex) GetKlineChannels() map[string]<-chan connector.Kline {
	p.klineMu.RLock()
	defer p.klineMu.RUnlock()

	result := make(map[string]<-chan connector.Kline, len(p.klineChannels))
	for key, ch := range p.klineChannels {
		result[key] = ch
	}

	p.appLogger.Info("ðŸ“Š Returning %d kline channels", len(result))
	return result
}

// GetOrderBookChannels returns all active orderbook channels
func (p *paradex) GetOrderBookChannels() map[string]<-chan connector.OrderBook {
	p.orderBookMu.RLock()
	defer p.orderBookMu.RUnlock()

	result := make(map[string]<-chan connector.OrderBook, len(p.orderBookChannels))
	for key, ch := range p.orderBookChannels {
		result[key] = ch
	}

	p.appLogger.Info("ðŸ“Š Returning %d orderbook channels", len(result))
	return result
}

// TradeUpdates returns a channel for trade updates
func (p *paradex) TradeUpdates() <-chan connector.Trade {
	return p.tradeCh
}

func (p *paradex) PositionUpdates() <-chan connector.Position {
	if p.wsService == nil {
		ch := make(chan connector.Position)
		close(ch)
		return ch
	}

	// TODO: Implement actual position updates conversion
	convertedChan := make(chan connector.Position, 100)
	go p.convertPositionUpdates(convertedChan)
	return convertedChan
}

func (p *paradex) AccountBalanceUpdates() <-chan connector.AccountBalance {
	if p.wsService == nil {
		ch := make(chan connector.AccountBalance)
		close(ch)
		return ch
	}

	// TODO: Implement actual account balance updates conversion
	convertedChan := make(chan connector.AccountBalance, 100)
	go p.convertAccountBalanceUpdates(convertedChan)
	return convertedChan
}

func (p *paradex) ErrorChannel() <-chan error {
	if p.wsService == nil {
		ch := make(chan error)
		close(ch)
		return ch
	}

	return p.wsService.ErrorChannel()
}

// Stub converter methods - implement these when you need the functionality
func (p *paradex) convertPositionUpdates(out chan<- connector.Position) {
	defer close(out)
	// TODO: Convert from paradex position format to connector.Position
	// For now, just a placeholder that doesn't send anything
	<-p.wsContext.Done()
}

func (p *paradex) convertAccountBalanceUpdates(out chan<- connector.AccountBalance) {
	defer close(out)
	// TODO: Convert from paradex balance format to connector.AccountBalance
	// For now, just a placeholder that doesn't send anything
	<-p.wsContext.Done()
}

func (p *paradex) convertKlineUpdates(out chan<- connector.Kline) {
	defer close(out)

	for {
		select {
		case <-p.wsContext.Done():
			return
		case paradexKline, ok := <-p.wsService.KlineUpdates():
			if !ok {
				return
			}

			// Convert from paradex KlineUpdate to connector.Kline
			connectorKline := connector.Kline{
				Symbol:      paradexKline.Symbol,
				Interval:    paradexKline.Interval,
				OpenTime:    paradexKline.OpenTime,
				Open:        paradexKline.Open,
				High:        paradexKline.High,
				Low:         paradexKline.Low,
				Close:       paradexKline.Close,
				Volume:      paradexKline.Volume,
				CloseTime:   paradexKline.CloseTime,
				QuoteVolume: numerical.Zero(),             // Not available from paradex
				TradeCount:  int(paradexKline.TradeCount), // Convert int64 to int
				TakerVolume: numerical.Zero(),             // Not available from paradex
			}

			select {
			case out <- connectorKline:
			case <-p.wsContext.Done():
				return
			default:
				// Channel full, drop update to prevent blocking
				p.appLogger.Debug("Dropped kline update for %s due to full channel", paradexKline.Symbol)
			}
		}
	}
}
