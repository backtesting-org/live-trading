// Code generated by mockery v2.53.5. DO NOT EDIT.

package real_time

import (
	connector "github.com/backtesting-org/kronos-sdk/pkg/types/connector"
	mock "github.com/stretchr/testify/mock"

	portfolio "github.com/backtesting-org/kronos-sdk/pkg/types/portfolio"

	real_time "github.com/backtesting-org/live-trading/pkg/connectors/bybit/data/real_time"
)

// RealTimeService is an autogenerated mock type for the RealTimeService type
type RealTimeService struct {
	mock.Mock
}

type RealTimeService_Expecter struct {
	mock *mock.Mock
}

func (_m *RealTimeService) EXPECT() *RealTimeService_Expecter {
	return &RealTimeService_Expecter{mock: &_m.Mock}
}

// Connect provides a mock function with no fields
func (_m *RealTimeService) Connect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type RealTimeService_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) Connect() *RealTimeService_Connect_Call {
	return &RealTimeService_Connect_Call{Call: _e.mock.On("Connect")}
}

func (_c *RealTimeService_Connect_Call) Run(run func()) *RealTimeService_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_Connect_Call) Return(_a0 error) *RealTimeService_Connect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_Connect_Call) RunAndReturn(run func() error) *RealTimeService_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// Disconnect provides a mock function with no fields
func (_m *RealTimeService) Disconnect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Disconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_Disconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disconnect'
type RealTimeService_Disconnect_Call struct {
	*mock.Call
}

// Disconnect is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) Disconnect() *RealTimeService_Disconnect_Call {
	return &RealTimeService_Disconnect_Call{Call: _e.mock.On("Disconnect")}
}

func (_c *RealTimeService_Disconnect_Call) Run(run func()) *RealTimeService_Disconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_Disconnect_Call) Return(_a0 error) *RealTimeService_Disconnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_Disconnect_Call) RunAndReturn(run func() error) *RealTimeService_Disconnect_Call {
	_c.Call.Return(run)
	return _c
}

// Initialize provides a mock function with given fields: config
func (_m *RealTimeService) Initialize(config *real_time.Config) error {
	ret := _m.Called(config)

	if len(ret) == 0 {
		panic("no return value specified for Initialize")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*real_time.Config) error); ok {
		r0 = rf(config)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_Initialize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Initialize'
type RealTimeService_Initialize_Call struct {
	*mock.Call
}

// Initialize is a helper method to define mock.On call
//   - config *real_time.Config
func (_e *RealTimeService_Expecter) Initialize(config interface{}) *RealTimeService_Initialize_Call {
	return &RealTimeService_Initialize_Call{Call: _e.mock.On("Initialize", config)}
}

func (_c *RealTimeService_Initialize_Call) Run(run func(config *real_time.Config)) *RealTimeService_Initialize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*real_time.Config))
	})
	return _c
}

func (_c *RealTimeService_Initialize_Call) Return(_a0 error) *RealTimeService_Initialize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_Initialize_Call) RunAndReturn(run func(*real_time.Config) error) *RealTimeService_Initialize_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeAccountBalance provides a mock function with no fields
func (_m *RealTimeService) SubscribeAccountBalance() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SubscribeAccountBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_SubscribeAccountBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeAccountBalance'
type RealTimeService_SubscribeAccountBalance_Call struct {
	*mock.Call
}

// SubscribeAccountBalance is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) SubscribeAccountBalance() *RealTimeService_SubscribeAccountBalance_Call {
	return &RealTimeService_SubscribeAccountBalance_Call{Call: _e.mock.On("SubscribeAccountBalance")}
}

func (_c *RealTimeService_SubscribeAccountBalance_Call) Run(run func()) *RealTimeService_SubscribeAccountBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_SubscribeAccountBalance_Call) Return(_a0 error) *RealTimeService_SubscribeAccountBalance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_SubscribeAccountBalance_Call) RunAndReturn(run func() error) *RealTimeService_SubscribeAccountBalance_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeKlines provides a mock function with given fields: asset, interval
func (_m *RealTimeService) SubscribeKlines(asset portfolio.Asset, interval string) error {
	ret := _m.Called(asset, interval)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeKlines")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, string) error); ok {
		r0 = rf(asset, interval)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_SubscribeKlines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeKlines'
type RealTimeService_SubscribeKlines_Call struct {
	*mock.Call
}

// SubscribeKlines is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - interval string
func (_e *RealTimeService_Expecter) SubscribeKlines(asset interface{}, interval interface{}) *RealTimeService_SubscribeKlines_Call {
	return &RealTimeService_SubscribeKlines_Call{Call: _e.mock.On("SubscribeKlines", asset, interval)}
}

func (_c *RealTimeService_SubscribeKlines_Call) Run(run func(asset portfolio.Asset, interval string)) *RealTimeService_SubscribeKlines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(string))
	})
	return _c
}

func (_c *RealTimeService_SubscribeKlines_Call) Return(_a0 error) *RealTimeService_SubscribeKlines_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_SubscribeKlines_Call) RunAndReturn(run func(portfolio.Asset, string) error) *RealTimeService_SubscribeKlines_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeOrderBook provides a mock function with given fields: asset, instrument
func (_m *RealTimeService) SubscribeOrderBook(asset portfolio.Asset, instrument connector.Instrument) error {
	ret := _m.Called(asset, instrument)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeOrderBook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, connector.Instrument) error); ok {
		r0 = rf(asset, instrument)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_SubscribeOrderBook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeOrderBook'
type RealTimeService_SubscribeOrderBook_Call struct {
	*mock.Call
}

// SubscribeOrderBook is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - instrument connector.Instrument
func (_e *RealTimeService_Expecter) SubscribeOrderBook(asset interface{}, instrument interface{}) *RealTimeService_SubscribeOrderBook_Call {
	return &RealTimeService_SubscribeOrderBook_Call{Call: _e.mock.On("SubscribeOrderBook", asset, instrument)}
}

func (_c *RealTimeService_SubscribeOrderBook_Call) Run(run func(asset portfolio.Asset, instrument connector.Instrument)) *RealTimeService_SubscribeOrderBook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(connector.Instrument))
	})
	return _c
}

func (_c *RealTimeService_SubscribeOrderBook_Call) Return(_a0 error) *RealTimeService_SubscribeOrderBook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_SubscribeOrderBook_Call) RunAndReturn(run func(portfolio.Asset, connector.Instrument) error) *RealTimeService_SubscribeOrderBook_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribePositions provides a mock function with given fields: asset, instrument
func (_m *RealTimeService) SubscribePositions(asset portfolio.Asset, instrument connector.Instrument) error {
	ret := _m.Called(asset, instrument)

	if len(ret) == 0 {
		panic("no return value specified for SubscribePositions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, connector.Instrument) error); ok {
		r0 = rf(asset, instrument)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_SubscribePositions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribePositions'
type RealTimeService_SubscribePositions_Call struct {
	*mock.Call
}

// SubscribePositions is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - instrument connector.Instrument
func (_e *RealTimeService_Expecter) SubscribePositions(asset interface{}, instrument interface{}) *RealTimeService_SubscribePositions_Call {
	return &RealTimeService_SubscribePositions_Call{Call: _e.mock.On("SubscribePositions", asset, instrument)}
}

func (_c *RealTimeService_SubscribePositions_Call) Run(run func(asset portfolio.Asset, instrument connector.Instrument)) *RealTimeService_SubscribePositions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(connector.Instrument))
	})
	return _c
}

func (_c *RealTimeService_SubscribePositions_Call) Return(_a0 error) *RealTimeService_SubscribePositions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_SubscribePositions_Call) RunAndReturn(run func(portfolio.Asset, connector.Instrument) error) *RealTimeService_SubscribePositions_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeTrades provides a mock function with given fields: asset, instrument
func (_m *RealTimeService) SubscribeTrades(asset portfolio.Asset, instrument connector.Instrument) error {
	ret := _m.Called(asset, instrument)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeTrades")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, connector.Instrument) error); ok {
		r0 = rf(asset, instrument)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_SubscribeTrades_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeTrades'
type RealTimeService_SubscribeTrades_Call struct {
	*mock.Call
}

// SubscribeTrades is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - instrument connector.Instrument
func (_e *RealTimeService_Expecter) SubscribeTrades(asset interface{}, instrument interface{}) *RealTimeService_SubscribeTrades_Call {
	return &RealTimeService_SubscribeTrades_Call{Call: _e.mock.On("SubscribeTrades", asset, instrument)}
}

func (_c *RealTimeService_SubscribeTrades_Call) Run(run func(asset portfolio.Asset, instrument connector.Instrument)) *RealTimeService_SubscribeTrades_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(connector.Instrument))
	})
	return _c
}

func (_c *RealTimeService_SubscribeTrades_Call) Return(_a0 error) *RealTimeService_SubscribeTrades_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_SubscribeTrades_Call) RunAndReturn(run func(portfolio.Asset, connector.Instrument) error) *RealTimeService_SubscribeTrades_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeAccountBalance provides a mock function with no fields
func (_m *RealTimeService) UnsubscribeAccountBalance() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeAccountBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribeAccountBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeAccountBalance'
type RealTimeService_UnsubscribeAccountBalance_Call struct {
	*mock.Call
}

// UnsubscribeAccountBalance is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) UnsubscribeAccountBalance() *RealTimeService_UnsubscribeAccountBalance_Call {
	return &RealTimeService_UnsubscribeAccountBalance_Call{Call: _e.mock.On("UnsubscribeAccountBalance")}
}

func (_c *RealTimeService_UnsubscribeAccountBalance_Call) Run(run func()) *RealTimeService_UnsubscribeAccountBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_UnsubscribeAccountBalance_Call) Return(_a0 error) *RealTimeService_UnsubscribeAccountBalance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribeAccountBalance_Call) RunAndReturn(run func() error) *RealTimeService_UnsubscribeAccountBalance_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeKlines provides a mock function with given fields: asset, interval
func (_m *RealTimeService) UnsubscribeKlines(asset portfolio.Asset, interval string) error {
	ret := _m.Called(asset, interval)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeKlines")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, string) error); ok {
		r0 = rf(asset, interval)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribeKlines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeKlines'
type RealTimeService_UnsubscribeKlines_Call struct {
	*mock.Call
}

// UnsubscribeKlines is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - interval string
func (_e *RealTimeService_Expecter) UnsubscribeKlines(asset interface{}, interval interface{}) *RealTimeService_UnsubscribeKlines_Call {
	return &RealTimeService_UnsubscribeKlines_Call{Call: _e.mock.On("UnsubscribeKlines", asset, interval)}
}

func (_c *RealTimeService_UnsubscribeKlines_Call) Run(run func(asset portfolio.Asset, interval string)) *RealTimeService_UnsubscribeKlines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(string))
	})
	return _c
}

func (_c *RealTimeService_UnsubscribeKlines_Call) Return(_a0 error) *RealTimeService_UnsubscribeKlines_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribeKlines_Call) RunAndReturn(run func(portfolio.Asset, string) error) *RealTimeService_UnsubscribeKlines_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeOrderBook provides a mock function with given fields: asset, instrument
func (_m *RealTimeService) UnsubscribeOrderBook(asset portfolio.Asset, instrument connector.Instrument) error {
	ret := _m.Called(asset, instrument)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeOrderBook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, connector.Instrument) error); ok {
		r0 = rf(asset, instrument)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribeOrderBook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeOrderBook'
type RealTimeService_UnsubscribeOrderBook_Call struct {
	*mock.Call
}

// UnsubscribeOrderBook is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - instrument connector.Instrument
func (_e *RealTimeService_Expecter) UnsubscribeOrderBook(asset interface{}, instrument interface{}) *RealTimeService_UnsubscribeOrderBook_Call {
	return &RealTimeService_UnsubscribeOrderBook_Call{Call: _e.mock.On("UnsubscribeOrderBook", asset, instrument)}
}

func (_c *RealTimeService_UnsubscribeOrderBook_Call) Run(run func(asset portfolio.Asset, instrument connector.Instrument)) *RealTimeService_UnsubscribeOrderBook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(connector.Instrument))
	})
	return _c
}

func (_c *RealTimeService_UnsubscribeOrderBook_Call) Return(_a0 error) *RealTimeService_UnsubscribeOrderBook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribeOrderBook_Call) RunAndReturn(run func(portfolio.Asset, connector.Instrument) error) *RealTimeService_UnsubscribeOrderBook_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribePositions provides a mock function with given fields: asset, instrument
func (_m *RealTimeService) UnsubscribePositions(asset portfolio.Asset, instrument connector.Instrument) error {
	ret := _m.Called(asset, instrument)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribePositions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, connector.Instrument) error); ok {
		r0 = rf(asset, instrument)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribePositions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribePositions'
type RealTimeService_UnsubscribePositions_Call struct {
	*mock.Call
}

// UnsubscribePositions is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - instrument connector.Instrument
func (_e *RealTimeService_Expecter) UnsubscribePositions(asset interface{}, instrument interface{}) *RealTimeService_UnsubscribePositions_Call {
	return &RealTimeService_UnsubscribePositions_Call{Call: _e.mock.On("UnsubscribePositions", asset, instrument)}
}

func (_c *RealTimeService_UnsubscribePositions_Call) Run(run func(asset portfolio.Asset, instrument connector.Instrument)) *RealTimeService_UnsubscribePositions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(connector.Instrument))
	})
	return _c
}

func (_c *RealTimeService_UnsubscribePositions_Call) Return(_a0 error) *RealTimeService_UnsubscribePositions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribePositions_Call) RunAndReturn(run func(portfolio.Asset, connector.Instrument) error) *RealTimeService_UnsubscribePositions_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeTrades provides a mock function with given fields: asset, instrument
func (_m *RealTimeService) UnsubscribeTrades(asset portfolio.Asset, instrument connector.Instrument) error {
	ret := _m.Called(asset, instrument)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeTrades")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(portfolio.Asset, connector.Instrument) error); ok {
		r0 = rf(asset, instrument)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribeTrades_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeTrades'
type RealTimeService_UnsubscribeTrades_Call struct {
	*mock.Call
}

// UnsubscribeTrades is a helper method to define mock.On call
//   - asset portfolio.Asset
//   - instrument connector.Instrument
func (_e *RealTimeService_Expecter) UnsubscribeTrades(asset interface{}, instrument interface{}) *RealTimeService_UnsubscribeTrades_Call {
	return &RealTimeService_UnsubscribeTrades_Call{Call: _e.mock.On("UnsubscribeTrades", asset, instrument)}
}

func (_c *RealTimeService_UnsubscribeTrades_Call) Run(run func(asset portfolio.Asset, instrument connector.Instrument)) *RealTimeService_UnsubscribeTrades_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(portfolio.Asset), args[1].(connector.Instrument))
	})
	return _c
}

func (_c *RealTimeService_UnsubscribeTrades_Call) Return(_a0 error) *RealTimeService_UnsubscribeTrades_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribeTrades_Call) RunAndReturn(run func(portfolio.Asset, connector.Instrument) error) *RealTimeService_UnsubscribeTrades_Call {
	_c.Call.Return(run)
	return _c
}

// NewRealTimeService creates a new instance of RealTimeService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRealTimeService(t interface {
	mock.TestingT
	Cleanup(func())
}) *RealTimeService {
	mock := &RealTimeService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
