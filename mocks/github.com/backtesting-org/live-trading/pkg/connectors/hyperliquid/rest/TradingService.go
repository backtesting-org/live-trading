// Code generated by mockery v2.53.5. DO NOT EDIT.

package rest

import (
	hyperliquid "github.com/sonirico/go-hyperliquid"
	mock "github.com/stretchr/testify/mock"
)

// TradingService is an autogenerated mock type for the TradingService type
type TradingService struct {
	mock.Mock
}

type TradingService_Expecter struct {
	mock *mock.Mock
}

func (_m *TradingService) EXPECT() *TradingService_Expecter {
	return &TradingService_Expecter{mock: &_m.Mock}
}

// CancelOrderByCustomRef provides a mock function with given fields: coin, customRef
func (_m *TradingService) CancelOrderByCustomRef(coin string, customRef string) (*hyperliquid.APIResponse[hyperliquid.CancelResponse], error) {
	ret := _m.Called(coin, customRef)

	if len(ret) == 0 {
		panic("no return value specified for CancelOrderByCustomRef")
	}

	var r0 *hyperliquid.APIResponse[hyperliquid.CancelResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*hyperliquid.APIResponse[hyperliquid.CancelResponse], error)); ok {
		return rf(coin, customRef)
	}
	if rf, ok := ret.Get(0).(func(string, string) *hyperliquid.APIResponse[hyperliquid.CancelResponse]); ok {
		r0 = rf(coin, customRef)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hyperliquid.APIResponse[hyperliquid.CancelResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(coin, customRef)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_CancelOrderByCustomRef_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelOrderByCustomRef'
type TradingService_CancelOrderByCustomRef_Call struct {
	*mock.Call
}

// CancelOrderByCustomRef is a helper method to define mock.On call
//   - coin string
//   - customRef string
func (_e *TradingService_Expecter) CancelOrderByCustomRef(coin interface{}, customRef interface{}) *TradingService_CancelOrderByCustomRef_Call {
	return &TradingService_CancelOrderByCustomRef_Call{Call: _e.mock.On("CancelOrderByCustomRef", coin, customRef)}
}

func (_c *TradingService_CancelOrderByCustomRef_Call) Run(run func(coin string, customRef string)) *TradingService_CancelOrderByCustomRef_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *TradingService_CancelOrderByCustomRef_Call) Return(_a0 *hyperliquid.APIResponse[hyperliquid.CancelResponse], _a1 error) *TradingService_CancelOrderByCustomRef_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_CancelOrderByCustomRef_Call) RunAndReturn(run func(string, string) (*hyperliquid.APIResponse[hyperliquid.CancelResponse], error)) *TradingService_CancelOrderByCustomRef_Call {
	_c.Call.Return(run)
	return _c
}

// CancelOrderByID provides a mock function with given fields: coin, orderID
func (_m *TradingService) CancelOrderByID(coin string, orderID int64) (*hyperliquid.APIResponse[hyperliquid.CancelResponse], error) {
	ret := _m.Called(coin, orderID)

	if len(ret) == 0 {
		panic("no return value specified for CancelOrderByID")
	}

	var r0 *hyperliquid.APIResponse[hyperliquid.CancelResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64) (*hyperliquid.APIResponse[hyperliquid.CancelResponse], error)); ok {
		return rf(coin, orderID)
	}
	if rf, ok := ret.Get(0).(func(string, int64) *hyperliquid.APIResponse[hyperliquid.CancelResponse]); ok {
		r0 = rf(coin, orderID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hyperliquid.APIResponse[hyperliquid.CancelResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(coin, orderID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_CancelOrderByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelOrderByID'
type TradingService_CancelOrderByID_Call struct {
	*mock.Call
}

// CancelOrderByID is a helper method to define mock.On call
//   - coin string
//   - orderID int64
func (_e *TradingService_Expecter) CancelOrderByID(coin interface{}, orderID interface{}) *TradingService_CancelOrderByID_Call {
	return &TradingService_CancelOrderByID_Call{Call: _e.mock.On("CancelOrderByID", coin, orderID)}
}

func (_c *TradingService_CancelOrderByID_Call) Run(run func(coin string, orderID int64)) *TradingService_CancelOrderByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *TradingService_CancelOrderByID_Call) Return(_a0 *hyperliquid.APIResponse[hyperliquid.CancelResponse], _a1 error) *TradingService_CancelOrderByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_CancelOrderByID_Call) RunAndReturn(run func(string, int64) (*hyperliquid.APIResponse[hyperliquid.CancelResponse], error)) *TradingService_CancelOrderByID_Call {
	_c.Call.Return(run)
	return _c
}

// CloseEntirePosition provides a mock function with given fields: coin, slippage
func (_m *TradingService) CloseEntirePosition(coin string, slippage float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, slippage)

	if len(ret) == 0 {
		panic("no return value specified for CloseEntirePosition")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, slippage)
	}
	if rf, ok := ret.Get(0).(func(string, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, slippage)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64) error); ok {
		r1 = rf(coin, slippage)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_CloseEntirePosition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloseEntirePosition'
type TradingService_CloseEntirePosition_Call struct {
	*mock.Call
}

// CloseEntirePosition is a helper method to define mock.On call
//   - coin string
//   - slippage float64
func (_e *TradingService_Expecter) CloseEntirePosition(coin interface{}, slippage interface{}) *TradingService_CloseEntirePosition_Call {
	return &TradingService_CloseEntirePosition_Call{Call: _e.mock.On("CloseEntirePosition", coin, slippage)}
}

func (_c *TradingService_CloseEntirePosition_Call) Run(run func(coin string, slippage float64)) *TradingService_CloseEntirePosition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64))
	})
	return _c
}

func (_c *TradingService_CloseEntirePosition_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_CloseEntirePosition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_CloseEntirePosition_Call) RunAndReturn(run func(string, float64) (hyperliquid.OrderStatus, error)) *TradingService_CloseEntirePosition_Call {
	_c.Call.Return(run)
	return _c
}

// ClosePosition provides a mock function with given fields: coin, size, slippage
func (_m *TradingService) ClosePosition(coin string, size *float64, slippage float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, slippage)

	if len(ret) == 0 {
		panic("no return value specified for ClosePosition")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, slippage)
	}
	if rf, ok := ret.Get(0).(func(string, *float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, slippage)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, *float64, float64) error); ok {
		r1 = rf(coin, size, slippage)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_ClosePosition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClosePosition'
type TradingService_ClosePosition_Call struct {
	*mock.Call
}

// ClosePosition is a helper method to define mock.On call
//   - coin string
//   - size *float64
//   - slippage float64
func (_e *TradingService_Expecter) ClosePosition(coin interface{}, size interface{}, slippage interface{}) *TradingService_ClosePosition_Call {
	return &TradingService_ClosePosition_Call{Call: _e.mock.On("ClosePosition", coin, size, slippage)}
}

func (_c *TradingService_ClosePosition_Call) Run(run func(coin string, size *float64, slippage float64)) *TradingService_ClosePosition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_ClosePosition_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_ClosePosition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_ClosePosition_Call) RunAndReturn(run func(string, *float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_ClosePosition_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyOrder provides a mock function with given fields: orderID, coin, size, price, isBuy
func (_m *TradingService) ModifyOrder(orderID int64, coin string, size float64, price float64, isBuy bool) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(orderID, coin, size, price, isBuy)

	if len(ret) == 0 {
		panic("no return value specified for ModifyOrder")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(int64, string, float64, float64, bool) (hyperliquid.OrderStatus, error)); ok {
		return rf(orderID, coin, size, price, isBuy)
	}
	if rf, ok := ret.Get(0).(func(int64, string, float64, float64, bool) hyperliquid.OrderStatus); ok {
		r0 = rf(orderID, coin, size, price, isBuy)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(int64, string, float64, float64, bool) error); ok {
		r1 = rf(orderID, coin, size, price, isBuy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_ModifyOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyOrder'
type TradingService_ModifyOrder_Call struct {
	*mock.Call
}

// ModifyOrder is a helper method to define mock.On call
//   - orderID int64
//   - coin string
//   - size float64
//   - price float64
//   - isBuy bool
func (_e *TradingService_Expecter) ModifyOrder(orderID interface{}, coin interface{}, size interface{}, price interface{}, isBuy interface{}) *TradingService_ModifyOrder_Call {
	return &TradingService_ModifyOrder_Call{Call: _e.mock.On("ModifyOrder", orderID, coin, size, price, isBuy)}
}

func (_c *TradingService_ModifyOrder_Call) Run(run func(orderID int64, coin string, size float64, price float64, isBuy bool)) *TradingService_ModifyOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(string), args[2].(float64), args[3].(float64), args[4].(bool))
	})
	return _c
}

func (_c *TradingService_ModifyOrder_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_ModifyOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_ModifyOrder_Call) RunAndReturn(run func(int64, string, float64, float64, bool) (hyperliquid.OrderStatus, error)) *TradingService_ModifyOrder_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceBulkOrders provides a mock function with given fields: orders
func (_m *TradingService) PlaceBulkOrders(orders []hyperliquid.CreateOrderRequest) (*hyperliquid.APIResponse[hyperliquid.OrderResponse], error) {
	ret := _m.Called(orders)

	if len(ret) == 0 {
		panic("no return value specified for PlaceBulkOrders")
	}

	var r0 *hyperliquid.APIResponse[hyperliquid.OrderResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func([]hyperliquid.CreateOrderRequest) (*hyperliquid.APIResponse[hyperliquid.OrderResponse], error)); ok {
		return rf(orders)
	}
	if rf, ok := ret.Get(0).(func([]hyperliquid.CreateOrderRequest) *hyperliquid.APIResponse[hyperliquid.OrderResponse]); ok {
		r0 = rf(orders)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hyperliquid.APIResponse[hyperliquid.OrderResponse])
		}
	}

	if rf, ok := ret.Get(1).(func([]hyperliquid.CreateOrderRequest) error); ok {
		r1 = rf(orders)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceBulkOrders_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceBulkOrders'
type TradingService_PlaceBulkOrders_Call struct {
	*mock.Call
}

// PlaceBulkOrders is a helper method to define mock.On call
//   - orders []hyperliquid.CreateOrderRequest
func (_e *TradingService_Expecter) PlaceBulkOrders(orders interface{}) *TradingService_PlaceBulkOrders_Call {
	return &TradingService_PlaceBulkOrders_Call{Call: _e.mock.On("PlaceBulkOrders", orders)}
}

func (_c *TradingService_PlaceBulkOrders_Call) Run(run func(orders []hyperliquid.CreateOrderRequest)) *TradingService_PlaceBulkOrders_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]hyperliquid.CreateOrderRequest))
	})
	return _c
}

func (_c *TradingService_PlaceBulkOrders_Call) Return(_a0 *hyperliquid.APIResponse[hyperliquid.OrderResponse], _a1 error) *TradingService_PlaceBulkOrders_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceBulkOrders_Call) RunAndReturn(run func([]hyperliquid.CreateOrderRequest) (*hyperliquid.APIResponse[hyperliquid.OrderResponse], error)) *TradingService_PlaceBulkOrders_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceBuyLimitOrder provides a mock function with given fields: coin, size, price
func (_m *TradingService) PlaceBuyLimitOrder(coin string, size float64, price float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, price)

	if len(ret) == 0 {
		panic("no return value specified for PlaceBuyLimitOrder")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, price)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, price)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, price)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceBuyLimitOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceBuyLimitOrder'
type TradingService_PlaceBuyLimitOrder_Call struct {
	*mock.Call
}

// PlaceBuyLimitOrder is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - price float64
func (_e *TradingService_Expecter) PlaceBuyLimitOrder(coin interface{}, size interface{}, price interface{}) *TradingService_PlaceBuyLimitOrder_Call {
	return &TradingService_PlaceBuyLimitOrder_Call{Call: _e.mock.On("PlaceBuyLimitOrder", coin, size, price)}
}

func (_c *TradingService_PlaceBuyLimitOrder_Call) Run(run func(coin string, size float64, price float64)) *TradingService_PlaceBuyLimitOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceBuyLimitOrder_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceBuyLimitOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceBuyLimitOrder_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceBuyLimitOrder_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceBuyLimitOrderWithCustomRef provides a mock function with given fields: coin, size, price, customRef
func (_m *TradingService) PlaceBuyLimitOrderWithCustomRef(coin string, size float64, price float64, customRef string) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, price, customRef)

	if len(ret) == 0 {
		panic("no return value specified for PlaceBuyLimitOrderWithCustomRef")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64, string) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, price, customRef)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64, string) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, price, customRef)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64, string) error); ok {
		r1 = rf(coin, size, price, customRef)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceBuyLimitOrderWithCustomRef_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceBuyLimitOrderWithCustomRef'
type TradingService_PlaceBuyLimitOrderWithCustomRef_Call struct {
	*mock.Call
}

// PlaceBuyLimitOrderWithCustomRef is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - price float64
//   - customRef string
func (_e *TradingService_Expecter) PlaceBuyLimitOrderWithCustomRef(coin interface{}, size interface{}, price interface{}, customRef interface{}) *TradingService_PlaceBuyLimitOrderWithCustomRef_Call {
	return &TradingService_PlaceBuyLimitOrderWithCustomRef_Call{Call: _e.mock.On("PlaceBuyLimitOrderWithCustomRef", coin, size, price, customRef)}
}

func (_c *TradingService_PlaceBuyLimitOrderWithCustomRef_Call) Run(run func(coin string, size float64, price float64, customRef string)) *TradingService_PlaceBuyLimitOrderWithCustomRef_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64), args[3].(string))
	})
	return _c
}

func (_c *TradingService_PlaceBuyLimitOrderWithCustomRef_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceBuyLimitOrderWithCustomRef_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceBuyLimitOrderWithCustomRef_Call) RunAndReturn(run func(string, float64, float64, string) (hyperliquid.OrderStatus, error)) *TradingService_PlaceBuyLimitOrderWithCustomRef_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceBuyMarketOrder provides a mock function with given fields: coin, size, slippage
func (_m *TradingService) PlaceBuyMarketOrder(coin string, size float64, slippage float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, slippage)

	if len(ret) == 0 {
		panic("no return value specified for PlaceBuyMarketOrder")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, slippage)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, slippage)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, slippage)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceBuyMarketOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceBuyMarketOrder'
type TradingService_PlaceBuyMarketOrder_Call struct {
	*mock.Call
}

// PlaceBuyMarketOrder is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - slippage float64
func (_e *TradingService_Expecter) PlaceBuyMarketOrder(coin interface{}, size interface{}, slippage interface{}) *TradingService_PlaceBuyMarketOrder_Call {
	return &TradingService_PlaceBuyMarketOrder_Call{Call: _e.mock.On("PlaceBuyMarketOrder", coin, size, slippage)}
}

func (_c *TradingService_PlaceBuyMarketOrder_Call) Run(run func(coin string, size float64, slippage float64)) *TradingService_PlaceBuyMarketOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceBuyMarketOrder_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceBuyMarketOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceBuyMarketOrder_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceBuyMarketOrder_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceBuyStopLoss provides a mock function with given fields: coin, size, triggerPrice
func (_m *TradingService) PlaceBuyStopLoss(coin string, size float64, triggerPrice float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, triggerPrice)

	if len(ret) == 0 {
		panic("no return value specified for PlaceBuyStopLoss")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, triggerPrice)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, triggerPrice)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, triggerPrice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceBuyStopLoss_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceBuyStopLoss'
type TradingService_PlaceBuyStopLoss_Call struct {
	*mock.Call
}

// PlaceBuyStopLoss is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - triggerPrice float64
func (_e *TradingService_Expecter) PlaceBuyStopLoss(coin interface{}, size interface{}, triggerPrice interface{}) *TradingService_PlaceBuyStopLoss_Call {
	return &TradingService_PlaceBuyStopLoss_Call{Call: _e.mock.On("PlaceBuyStopLoss", coin, size, triggerPrice)}
}

func (_c *TradingService_PlaceBuyStopLoss_Call) Run(run func(coin string, size float64, triggerPrice float64)) *TradingService_PlaceBuyStopLoss_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceBuyStopLoss_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceBuyStopLoss_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceBuyStopLoss_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceBuyStopLoss_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceBuyTakeProfit provides a mock function with given fields: coin, size, triggerPrice
func (_m *TradingService) PlaceBuyTakeProfit(coin string, size float64, triggerPrice float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, triggerPrice)

	if len(ret) == 0 {
		panic("no return value specified for PlaceBuyTakeProfit")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, triggerPrice)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, triggerPrice)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, triggerPrice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceBuyTakeProfit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceBuyTakeProfit'
type TradingService_PlaceBuyTakeProfit_Call struct {
	*mock.Call
}

// PlaceBuyTakeProfit is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - triggerPrice float64
func (_e *TradingService_Expecter) PlaceBuyTakeProfit(coin interface{}, size interface{}, triggerPrice interface{}) *TradingService_PlaceBuyTakeProfit_Call {
	return &TradingService_PlaceBuyTakeProfit_Call{Call: _e.mock.On("PlaceBuyTakeProfit", coin, size, triggerPrice)}
}

func (_c *TradingService_PlaceBuyTakeProfit_Call) Run(run func(coin string, size float64, triggerPrice float64)) *TradingService_PlaceBuyTakeProfit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceBuyTakeProfit_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceBuyTakeProfit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceBuyTakeProfit_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceBuyTakeProfit_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceSellLimitOrder provides a mock function with given fields: coin, size, price
func (_m *TradingService) PlaceSellLimitOrder(coin string, size float64, price float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, price)

	if len(ret) == 0 {
		panic("no return value specified for PlaceSellLimitOrder")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, price)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, price)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, price)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceSellLimitOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceSellLimitOrder'
type TradingService_PlaceSellLimitOrder_Call struct {
	*mock.Call
}

// PlaceSellLimitOrder is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - price float64
func (_e *TradingService_Expecter) PlaceSellLimitOrder(coin interface{}, size interface{}, price interface{}) *TradingService_PlaceSellLimitOrder_Call {
	return &TradingService_PlaceSellLimitOrder_Call{Call: _e.mock.On("PlaceSellLimitOrder", coin, size, price)}
}

func (_c *TradingService_PlaceSellLimitOrder_Call) Run(run func(coin string, size float64, price float64)) *TradingService_PlaceSellLimitOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceSellLimitOrder_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceSellLimitOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceSellLimitOrder_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceSellLimitOrder_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceSellLimitOrderWithCustomRef provides a mock function with given fields: coin, size, price, customRef
func (_m *TradingService) PlaceSellLimitOrderWithCustomRef(coin string, size float64, price float64, customRef string) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, price, customRef)

	if len(ret) == 0 {
		panic("no return value specified for PlaceSellLimitOrderWithCustomRef")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64, string) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, price, customRef)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64, string) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, price, customRef)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64, string) error); ok {
		r1 = rf(coin, size, price, customRef)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceSellLimitOrderWithCustomRef_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceSellLimitOrderWithCustomRef'
type TradingService_PlaceSellLimitOrderWithCustomRef_Call struct {
	*mock.Call
}

// PlaceSellLimitOrderWithCustomRef is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - price float64
//   - customRef string
func (_e *TradingService_Expecter) PlaceSellLimitOrderWithCustomRef(coin interface{}, size interface{}, price interface{}, customRef interface{}) *TradingService_PlaceSellLimitOrderWithCustomRef_Call {
	return &TradingService_PlaceSellLimitOrderWithCustomRef_Call{Call: _e.mock.On("PlaceSellLimitOrderWithCustomRef", coin, size, price, customRef)}
}

func (_c *TradingService_PlaceSellLimitOrderWithCustomRef_Call) Run(run func(coin string, size float64, price float64, customRef string)) *TradingService_PlaceSellLimitOrderWithCustomRef_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64), args[3].(string))
	})
	return _c
}

func (_c *TradingService_PlaceSellLimitOrderWithCustomRef_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceSellLimitOrderWithCustomRef_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceSellLimitOrderWithCustomRef_Call) RunAndReturn(run func(string, float64, float64, string) (hyperliquid.OrderStatus, error)) *TradingService_PlaceSellLimitOrderWithCustomRef_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceSellMarketOrder provides a mock function with given fields: coin, size, slippage
func (_m *TradingService) PlaceSellMarketOrder(coin string, size float64, slippage float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, slippage)

	if len(ret) == 0 {
		panic("no return value specified for PlaceSellMarketOrder")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, slippage)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, slippage)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, slippage)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceSellMarketOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceSellMarketOrder'
type TradingService_PlaceSellMarketOrder_Call struct {
	*mock.Call
}

// PlaceSellMarketOrder is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - slippage float64
func (_e *TradingService_Expecter) PlaceSellMarketOrder(coin interface{}, size interface{}, slippage interface{}) *TradingService_PlaceSellMarketOrder_Call {
	return &TradingService_PlaceSellMarketOrder_Call{Call: _e.mock.On("PlaceSellMarketOrder", coin, size, slippage)}
}

func (_c *TradingService_PlaceSellMarketOrder_Call) Run(run func(coin string, size float64, slippage float64)) *TradingService_PlaceSellMarketOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceSellMarketOrder_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceSellMarketOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceSellMarketOrder_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceSellMarketOrder_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceSellStopLoss provides a mock function with given fields: coin, size, triggerPrice
func (_m *TradingService) PlaceSellStopLoss(coin string, size float64, triggerPrice float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, triggerPrice)

	if len(ret) == 0 {
		panic("no return value specified for PlaceSellStopLoss")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, triggerPrice)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, triggerPrice)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, triggerPrice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceSellStopLoss_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceSellStopLoss'
type TradingService_PlaceSellStopLoss_Call struct {
	*mock.Call
}

// PlaceSellStopLoss is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - triggerPrice float64
func (_e *TradingService_Expecter) PlaceSellStopLoss(coin interface{}, size interface{}, triggerPrice interface{}) *TradingService_PlaceSellStopLoss_Call {
	return &TradingService_PlaceSellStopLoss_Call{Call: _e.mock.On("PlaceSellStopLoss", coin, size, triggerPrice)}
}

func (_c *TradingService_PlaceSellStopLoss_Call) Run(run func(coin string, size float64, triggerPrice float64)) *TradingService_PlaceSellStopLoss_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceSellStopLoss_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceSellStopLoss_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceSellStopLoss_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceSellStopLoss_Call {
	_c.Call.Return(run)
	return _c
}

// PlaceSellTakeProfit provides a mock function with given fields: coin, size, triggerPrice
func (_m *TradingService) PlaceSellTakeProfit(coin string, size float64, triggerPrice float64) (hyperliquid.OrderStatus, error) {
	ret := _m.Called(coin, size, triggerPrice)

	if len(ret) == 0 {
		panic("no return value specified for PlaceSellTakeProfit")
	}

	var r0 hyperliquid.OrderStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string, float64, float64) (hyperliquid.OrderStatus, error)); ok {
		return rf(coin, size, triggerPrice)
	}
	if rf, ok := ret.Get(0).(func(string, float64, float64) hyperliquid.OrderStatus); ok {
		r0 = rf(coin, size, triggerPrice)
	} else {
		r0 = ret.Get(0).(hyperliquid.OrderStatus)
	}

	if rf, ok := ret.Get(1).(func(string, float64, float64) error); ok {
		r1 = rf(coin, size, triggerPrice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TradingService_PlaceSellTakeProfit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlaceSellTakeProfit'
type TradingService_PlaceSellTakeProfit_Call struct {
	*mock.Call
}

// PlaceSellTakeProfit is a helper method to define mock.On call
//   - coin string
//   - size float64
//   - triggerPrice float64
func (_e *TradingService_Expecter) PlaceSellTakeProfit(coin interface{}, size interface{}, triggerPrice interface{}) *TradingService_PlaceSellTakeProfit_Call {
	return &TradingService_PlaceSellTakeProfit_Call{Call: _e.mock.On("PlaceSellTakeProfit", coin, size, triggerPrice)}
}

func (_c *TradingService_PlaceSellTakeProfit_Call) Run(run func(coin string, size float64, triggerPrice float64)) *TradingService_PlaceSellTakeProfit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(float64), args[2].(float64))
	})
	return _c
}

func (_c *TradingService_PlaceSellTakeProfit_Call) Return(_a0 hyperliquid.OrderStatus, _a1 error) *TradingService_PlaceSellTakeProfit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TradingService_PlaceSellTakeProfit_Call) RunAndReturn(run func(string, float64, float64) (hyperliquid.OrderStatus, error)) *TradingService_PlaceSellTakeProfit_Call {
	_c.Call.Return(run)
	return _c
}

// NewTradingService creates a new instance of TradingService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTradingService(t interface {
	mock.TestingT
	Cleanup(func())
}) *TradingService {
	mock := &TradingService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
