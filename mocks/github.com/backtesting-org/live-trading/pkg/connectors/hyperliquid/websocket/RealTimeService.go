// Code generated by mockery v2.53.5. DO NOT EDIT.

package websocket

import (
	websocket "github.com/backtesting-org/live-trading/pkg/connectors/hyperliquid/websocket"
	mock "github.com/stretchr/testify/mock"
)

// RealTimeService is an autogenerated mock type for the RealTimeService type
type RealTimeService struct {
	mock.Mock
}

type RealTimeService_Expecter struct {
	mock *mock.Mock
}

func (_m *RealTimeService) EXPECT() *RealTimeService_Expecter {
	return &RealTimeService_Expecter{mock: &_m.Mock}
}

// Connect provides a mock function with no fields
func (_m *RealTimeService) Connect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type RealTimeService_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) Connect() *RealTimeService_Connect_Call {
	return &RealTimeService_Connect_Call{Call: _e.mock.On("Connect")}
}

func (_c *RealTimeService_Connect_Call) Run(run func()) *RealTimeService_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_Connect_Call) Return(_a0 error) *RealTimeService_Connect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_Connect_Call) RunAndReturn(run func() error) *RealTimeService_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// Disconnect provides a mock function with no fields
func (_m *RealTimeService) Disconnect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Disconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_Disconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disconnect'
type RealTimeService_Disconnect_Call struct {
	*mock.Call
}

// Disconnect is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) Disconnect() *RealTimeService_Disconnect_Call {
	return &RealTimeService_Disconnect_Call{Call: _e.mock.On("Disconnect")}
}

func (_c *RealTimeService_Disconnect_Call) Run(run func()) *RealTimeService_Disconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_Disconnect_Call) Return(_a0 error) *RealTimeService_Disconnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_Disconnect_Call) RunAndReturn(run func() error) *RealTimeService_Disconnect_Call {
	_c.Call.Return(run)
	return _c
}

// GetErrorChannel provides a mock function with no fields
func (_m *RealTimeService) GetErrorChannel() <-chan error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetErrorChannel")
	}

	var r0 <-chan error
	if rf, ok := ret.Get(0).(func() <-chan error); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan error)
		}
	}

	return r0
}

// RealTimeService_GetErrorChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetErrorChannel'
type RealTimeService_GetErrorChannel_Call struct {
	*mock.Call
}

// GetErrorChannel is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) GetErrorChannel() *RealTimeService_GetErrorChannel_Call {
	return &RealTimeService_GetErrorChannel_Call{Call: _e.mock.On("GetErrorChannel")}
}

func (_c *RealTimeService_GetErrorChannel_Call) Run(run func()) *RealTimeService_GetErrorChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_GetErrorChannel_Call) Return(_a0 <-chan error) *RealTimeService_GetErrorChannel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_GetErrorChannel_Call) RunAndReturn(run func() <-chan error) *RealTimeService_GetErrorChannel_Call {
	_c.Call.Return(run)
	return _c
}

// IsConnected provides a mock function with no fields
func (_m *RealTimeService) IsConnected() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsConnected")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// RealTimeService_IsConnected_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConnected'
type RealTimeService_IsConnected_Call struct {
	*mock.Call
}

// IsConnected is a helper method to define mock.On call
func (_e *RealTimeService_Expecter) IsConnected() *RealTimeService_IsConnected_Call {
	return &RealTimeService_IsConnected_Call{Call: _e.mock.On("IsConnected")}
}

func (_c *RealTimeService_IsConnected_Call) Run(run func()) *RealTimeService_IsConnected_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RealTimeService_IsConnected_Call) Return(_a0 bool) *RealTimeService_IsConnected_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_IsConnected_Call) RunAndReturn(run func() bool) *RealTimeService_IsConnected_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToAccountBalance provides a mock function with given fields: user, callback
func (_m *RealTimeService) SubscribeToAccountBalance(user string, callback func(*websocket.AccountBalanceMessage)) (int, error) {
	ret := _m.Called(user, callback)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToAccountBalance")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string, func(*websocket.AccountBalanceMessage)) (int, error)); ok {
		return rf(user, callback)
	}
	if rf, ok := ret.Get(0).(func(string, func(*websocket.AccountBalanceMessage)) int); ok {
		r0 = rf(user, callback)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string, func(*websocket.AccountBalanceMessage)) error); ok {
		r1 = rf(user, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RealTimeService_SubscribeToAccountBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToAccountBalance'
type RealTimeService_SubscribeToAccountBalance_Call struct {
	*mock.Call
}

// SubscribeToAccountBalance is a helper method to define mock.On call
//   - user string
//   - callback func(*websocket.AccountBalanceMessage)
func (_e *RealTimeService_Expecter) SubscribeToAccountBalance(user interface{}, callback interface{}) *RealTimeService_SubscribeToAccountBalance_Call {
	return &RealTimeService_SubscribeToAccountBalance_Call{Call: _e.mock.On("SubscribeToAccountBalance", user, callback)}
}

func (_c *RealTimeService_SubscribeToAccountBalance_Call) Run(run func(user string, callback func(*websocket.AccountBalanceMessage))) *RealTimeService_SubscribeToAccountBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func(*websocket.AccountBalanceMessage)))
	})
	return _c
}

func (_c *RealTimeService_SubscribeToAccountBalance_Call) Return(_a0 int, _a1 error) *RealTimeService_SubscribeToAccountBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RealTimeService_SubscribeToAccountBalance_Call) RunAndReturn(run func(string, func(*websocket.AccountBalanceMessage)) (int, error)) *RealTimeService_SubscribeToAccountBalance_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToKlines provides a mock function with given fields: coin, interval, callback
func (_m *RealTimeService) SubscribeToKlines(coin string, interval string, callback func(*websocket.KlineMessage)) (int, error) {
	ret := _m.Called(coin, interval, callback)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToKlines")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, func(*websocket.KlineMessage)) (int, error)); ok {
		return rf(coin, interval, callback)
	}
	if rf, ok := ret.Get(0).(func(string, string, func(*websocket.KlineMessage)) int); ok {
		r0 = rf(coin, interval, callback)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string, string, func(*websocket.KlineMessage)) error); ok {
		r1 = rf(coin, interval, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RealTimeService_SubscribeToKlines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToKlines'
type RealTimeService_SubscribeToKlines_Call struct {
	*mock.Call
}

// SubscribeToKlines is a helper method to define mock.On call
//   - coin string
//   - interval string
//   - callback func(*websocket.KlineMessage)
func (_e *RealTimeService_Expecter) SubscribeToKlines(coin interface{}, interval interface{}, callback interface{}) *RealTimeService_SubscribeToKlines_Call {
	return &RealTimeService_SubscribeToKlines_Call{Call: _e.mock.On("SubscribeToKlines", coin, interval, callback)}
}

func (_c *RealTimeService_SubscribeToKlines_Call) Run(run func(coin string, interval string, callback func(*websocket.KlineMessage))) *RealTimeService_SubscribeToKlines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(func(*websocket.KlineMessage)))
	})
	return _c
}

func (_c *RealTimeService_SubscribeToKlines_Call) Return(_a0 int, _a1 error) *RealTimeService_SubscribeToKlines_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RealTimeService_SubscribeToKlines_Call) RunAndReturn(run func(string, string, func(*websocket.KlineMessage)) (int, error)) *RealTimeService_SubscribeToKlines_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToOrderBook provides a mock function with given fields: coin, callback
func (_m *RealTimeService) SubscribeToOrderBook(coin string, callback func(*websocket.OrderBookMessage)) (int, error) {
	ret := _m.Called(coin, callback)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToOrderBook")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string, func(*websocket.OrderBookMessage)) (int, error)); ok {
		return rf(coin, callback)
	}
	if rf, ok := ret.Get(0).(func(string, func(*websocket.OrderBookMessage)) int); ok {
		r0 = rf(coin, callback)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string, func(*websocket.OrderBookMessage)) error); ok {
		r1 = rf(coin, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RealTimeService_SubscribeToOrderBook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToOrderBook'
type RealTimeService_SubscribeToOrderBook_Call struct {
	*mock.Call
}

// SubscribeToOrderBook is a helper method to define mock.On call
//   - coin string
//   - callback func(*websocket.OrderBookMessage)
func (_e *RealTimeService_Expecter) SubscribeToOrderBook(coin interface{}, callback interface{}) *RealTimeService_SubscribeToOrderBook_Call {
	return &RealTimeService_SubscribeToOrderBook_Call{Call: _e.mock.On("SubscribeToOrderBook", coin, callback)}
}

func (_c *RealTimeService_SubscribeToOrderBook_Call) Run(run func(coin string, callback func(*websocket.OrderBookMessage))) *RealTimeService_SubscribeToOrderBook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func(*websocket.OrderBookMessage)))
	})
	return _c
}

func (_c *RealTimeService_SubscribeToOrderBook_Call) Return(_a0 int, _a1 error) *RealTimeService_SubscribeToOrderBook_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RealTimeService_SubscribeToOrderBook_Call) RunAndReturn(run func(string, func(*websocket.OrderBookMessage)) (int, error)) *RealTimeService_SubscribeToOrderBook_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToPositions provides a mock function with given fields: user, callback
func (_m *RealTimeService) SubscribeToPositions(user string, callback func(*websocket.PositionMessage)) (int, error) {
	ret := _m.Called(user, callback)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToPositions")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string, func(*websocket.PositionMessage)) (int, error)); ok {
		return rf(user, callback)
	}
	if rf, ok := ret.Get(0).(func(string, func(*websocket.PositionMessage)) int); ok {
		r0 = rf(user, callback)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string, func(*websocket.PositionMessage)) error); ok {
		r1 = rf(user, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RealTimeService_SubscribeToPositions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToPositions'
type RealTimeService_SubscribeToPositions_Call struct {
	*mock.Call
}

// SubscribeToPositions is a helper method to define mock.On call
//   - user string
//   - callback func(*websocket.PositionMessage)
func (_e *RealTimeService_Expecter) SubscribeToPositions(user interface{}, callback interface{}) *RealTimeService_SubscribeToPositions_Call {
	return &RealTimeService_SubscribeToPositions_Call{Call: _e.mock.On("SubscribeToPositions", user, callback)}
}

func (_c *RealTimeService_SubscribeToPositions_Call) Run(run func(user string, callback func(*websocket.PositionMessage))) *RealTimeService_SubscribeToPositions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func(*websocket.PositionMessage)))
	})
	return _c
}

func (_c *RealTimeService_SubscribeToPositions_Call) Return(_a0 int, _a1 error) *RealTimeService_SubscribeToPositions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RealTimeService_SubscribeToPositions_Call) RunAndReturn(run func(string, func(*websocket.PositionMessage)) (int, error)) *RealTimeService_SubscribeToPositions_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToTrades provides a mock function with given fields: coin, callback
func (_m *RealTimeService) SubscribeToTrades(coin string, callback func([]websocket.TradeMessage)) (int, error) {
	ret := _m.Called(coin, callback)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToTrades")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string, func([]websocket.TradeMessage)) (int, error)); ok {
		return rf(coin, callback)
	}
	if rf, ok := ret.Get(0).(func(string, func([]websocket.TradeMessage)) int); ok {
		r0 = rf(coin, callback)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string, func([]websocket.TradeMessage)) error); ok {
		r1 = rf(coin, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RealTimeService_SubscribeToTrades_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToTrades'
type RealTimeService_SubscribeToTrades_Call struct {
	*mock.Call
}

// SubscribeToTrades is a helper method to define mock.On call
//   - coin string
//   - callback func([]websocket.TradeMessage)
func (_e *RealTimeService_Expecter) SubscribeToTrades(coin interface{}, callback interface{}) *RealTimeService_SubscribeToTrades_Call {
	return &RealTimeService_SubscribeToTrades_Call{Call: _e.mock.On("SubscribeToTrades", coin, callback)}
}

func (_c *RealTimeService_SubscribeToTrades_Call) Run(run func(coin string, callback func([]websocket.TradeMessage))) *RealTimeService_SubscribeToTrades_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func([]websocket.TradeMessage)))
	})
	return _c
}

func (_c *RealTimeService_SubscribeToTrades_Call) Return(_a0 int, _a1 error) *RealTimeService_SubscribeToTrades_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RealTimeService_SubscribeToTrades_Call) RunAndReturn(run func(string, func([]websocket.TradeMessage)) (int, error)) *RealTimeService_SubscribeToTrades_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeFromKlines provides a mock function with given fields: coin, interval, subscriptionID
func (_m *RealTimeService) UnsubscribeFromKlines(coin string, interval string, subscriptionID int) error {
	ret := _m.Called(coin, interval, subscriptionID)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeFromKlines")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int) error); ok {
		r0 = rf(coin, interval, subscriptionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribeFromKlines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeFromKlines'
type RealTimeService_UnsubscribeFromKlines_Call struct {
	*mock.Call
}

// UnsubscribeFromKlines is a helper method to define mock.On call
//   - coin string
//   - interval string
//   - subscriptionID int
func (_e *RealTimeService_Expecter) UnsubscribeFromKlines(coin interface{}, interval interface{}, subscriptionID interface{}) *RealTimeService_UnsubscribeFromKlines_Call {
	return &RealTimeService_UnsubscribeFromKlines_Call{Call: _e.mock.On("UnsubscribeFromKlines", coin, interval, subscriptionID)}
}

func (_c *RealTimeService_UnsubscribeFromKlines_Call) Run(run func(coin string, interval string, subscriptionID int)) *RealTimeService_UnsubscribeFromKlines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *RealTimeService_UnsubscribeFromKlines_Call) Return(_a0 error) *RealTimeService_UnsubscribeFromKlines_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribeFromKlines_Call) RunAndReturn(run func(string, string, int) error) *RealTimeService_UnsubscribeFromKlines_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeFromOrderBook provides a mock function with given fields: coin, subscriptionID
func (_m *RealTimeService) UnsubscribeFromOrderBook(coin string, subscriptionID int) error {
	ret := _m.Called(coin, subscriptionID)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeFromOrderBook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int) error); ok {
		r0 = rf(coin, subscriptionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribeFromOrderBook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeFromOrderBook'
type RealTimeService_UnsubscribeFromOrderBook_Call struct {
	*mock.Call
}

// UnsubscribeFromOrderBook is a helper method to define mock.On call
//   - coin string
//   - subscriptionID int
func (_e *RealTimeService_Expecter) UnsubscribeFromOrderBook(coin interface{}, subscriptionID interface{}) *RealTimeService_UnsubscribeFromOrderBook_Call {
	return &RealTimeService_UnsubscribeFromOrderBook_Call{Call: _e.mock.On("UnsubscribeFromOrderBook", coin, subscriptionID)}
}

func (_c *RealTimeService_UnsubscribeFromOrderBook_Call) Run(run func(coin string, subscriptionID int)) *RealTimeService_UnsubscribeFromOrderBook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *RealTimeService_UnsubscribeFromOrderBook_Call) Return(_a0 error) *RealTimeService_UnsubscribeFromOrderBook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribeFromOrderBook_Call) RunAndReturn(run func(string, int) error) *RealTimeService_UnsubscribeFromOrderBook_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeFromTrades provides a mock function with given fields: coin, subscriptionID
func (_m *RealTimeService) UnsubscribeFromTrades(coin string, subscriptionID int) error {
	ret := _m.Called(coin, subscriptionID)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeFromTrades")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int) error); ok {
		r0 = rf(coin, subscriptionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RealTimeService_UnsubscribeFromTrades_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeFromTrades'
type RealTimeService_UnsubscribeFromTrades_Call struct {
	*mock.Call
}

// UnsubscribeFromTrades is a helper method to define mock.On call
//   - coin string
//   - subscriptionID int
func (_e *RealTimeService_Expecter) UnsubscribeFromTrades(coin interface{}, subscriptionID interface{}) *RealTimeService_UnsubscribeFromTrades_Call {
	return &RealTimeService_UnsubscribeFromTrades_Call{Call: _e.mock.On("UnsubscribeFromTrades", coin, subscriptionID)}
}

func (_c *RealTimeService_UnsubscribeFromTrades_Call) Run(run func(coin string, subscriptionID int)) *RealTimeService_UnsubscribeFromTrades_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *RealTimeService_UnsubscribeFromTrades_Call) Return(_a0 error) *RealTimeService_UnsubscribeFromTrades_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RealTimeService_UnsubscribeFromTrades_Call) RunAndReturn(run func(string, int) error) *RealTimeService_UnsubscribeFromTrades_Call {
	_c.Call.Return(run)
	return _c
}

// NewRealTimeService creates a new instance of RealTimeService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRealTimeService(t interface {
	mock.TestingT
	Cleanup(func())
}) *RealTimeService {
	mock := &RealTimeService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
